#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Blur::ScoreType;
use constant SUPER => 0;
use constant AGGREGATE => 1;
use constant BEST => 2;
use constant CONSTANT => 3;
package Blur::QueryState;
use constant RUNNING => 0;
use constant INTERRUPTED => 1;
use constant COMPLETE => 2;
package Blur::RecordMutationType;
use constant DELETE_ENTIRE_RECORD => 0;
use constant REPLACE_ENTIRE_RECORD => 1;
use constant REPLACE_COLUMNS => 2;
use constant APPEND_COLUMN_VALUES => 3;
package Blur::RowMutationType;
use constant DELETE_ROW => 0;
use constant REPLACE_ROW => 1;
use constant UPDATE_ROW => 2;
package Blur::BlurException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Blur::BlurException->mk_accessors( qw( message stackTraceStr ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stackTraceStr} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stackTraceStr}) {
      $self->{stackTraceStr} = $vals->{stackTraceStr};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stackTraceStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stackTraceStr}) {
    $xfer += $output->writeFieldBegin('stackTraceStr', TType::STRING, 2);
    $xfer += $output->writeString($self->{stackTraceStr});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::AlternateColumnDefinition;
use base qw(Class::Accessor);
Blur::AlternateColumnDefinition->mk_accessors( qw( analyzerClassName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{analyzerClassName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{analyzerClassName}) {
      $self->{analyzerClassName} = $vals->{analyzerClassName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AlternateColumnDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{analyzerClassName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AlternateColumnDefinition');
  if (defined $self->{analyzerClassName}) {
    $xfer += $output->writeFieldBegin('analyzerClassName', TType::STRING, 1);
    $xfer += $output->writeString($self->{analyzerClassName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ColumnDefinition;
use base qw(Class::Accessor);
Blur::ColumnDefinition->mk_accessors( qw( analyzerClassName fullTextIndex alternateColumnDefinitions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{analyzerClassName} = undef;
  $self->{fullTextIndex} = undef;
  $self->{alternateColumnDefinitions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{analyzerClassName}) {
      $self->{analyzerClassName} = $vals->{analyzerClassName};
    }
    if (defined $vals->{fullTextIndex}) {
      $self->{fullTextIndex} = $vals->{fullTextIndex};
    }
    if (defined $vals->{alternateColumnDefinitions}) {
      $self->{alternateColumnDefinitions} = $vals->{alternateColumnDefinitions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{analyzerClassName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{fullTextIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size0 = 0;
          $self->{alternateColumnDefinitions} = {};
          my $_ktype1 = 0;
          my $_vtype2 = 0;
          $xfer += $input->readMapBegin(\$_ktype1, \$_vtype2, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $key5 = '';
            my $val6 = new Blur::AlternateColumnDefinition();
            $xfer += $input->readString(\$key5);
            $val6 = new Blur::AlternateColumnDefinition();
            $xfer += $val6->read($input);
            $self->{alternateColumnDefinitions}->{$key5} = $val6;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnDefinition');
  if (defined $self->{analyzerClassName}) {
    $xfer += $output->writeFieldBegin('analyzerClassName', TType::STRING, 1);
    $xfer += $output->writeString($self->{analyzerClassName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fullTextIndex}) {
    $xfer += $output->writeFieldBegin('fullTextIndex', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{fullTextIndex});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{alternateColumnDefinitions}) {
    $xfer += $output->writeFieldBegin('alternateColumnDefinitions', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{alternateColumnDefinitions}}));
      {
        while( my ($kiter7,$viter8) = each %{$self->{alternateColumnDefinitions}}) 
        {
          $xfer += $output->writeString($kiter7);
          $xfer += ${viter8}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ColumnFamilyDefinition;
use base qw(Class::Accessor);
Blur::ColumnFamilyDefinition->mk_accessors( qw( defaultDefinition columnDefinitions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{defaultDefinition} = undef;
  $self->{columnDefinitions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{defaultDefinition}) {
      $self->{defaultDefinition} = $vals->{defaultDefinition};
    }
    if (defined $vals->{columnDefinitions}) {
      $self->{columnDefinitions} = $vals->{columnDefinitions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnFamilyDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{defaultDefinition} = new Blur::ColumnDefinition();
        $xfer += $self->{defaultDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size9 = 0;
          $self->{columnDefinitions} = {};
          my $_ktype10 = 0;
          my $_vtype11 = 0;
          $xfer += $input->readMapBegin(\$_ktype10, \$_vtype11, \$_size9);
          for (my $_i13 = 0; $_i13 < $_size9; ++$_i13)
          {
            my $key14 = '';
            my $val15 = new Blur::ColumnDefinition();
            $xfer += $input->readString(\$key14);
            $val15 = new Blur::ColumnDefinition();
            $xfer += $val15->read($input);
            $self->{columnDefinitions}->{$key14} = $val15;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnFamilyDefinition');
  if (defined $self->{defaultDefinition}) {
    $xfer += $output->writeFieldBegin('defaultDefinition', TType::STRUCT, 1);
    $xfer += $self->{defaultDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnDefinitions}) {
    $xfer += $output->writeFieldBegin('columnDefinitions', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{columnDefinitions}}));
      {
        while( my ($kiter16,$viter17) = each %{$self->{columnDefinitions}}) 
        {
          $xfer += $output->writeString($kiter16);
          $xfer += ${viter17}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::AnalyzerDefinition;
use base qw(Class::Accessor);
Blur::AnalyzerDefinition->mk_accessors( qw( defaultDefinition fullTextAnalyzerClassName columnFamilyDefinitions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{defaultDefinition} = undef;
  $self->{fullTextAnalyzerClassName} = undef;
  $self->{columnFamilyDefinitions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{defaultDefinition}) {
      $self->{defaultDefinition} = $vals->{defaultDefinition};
    }
    if (defined $vals->{fullTextAnalyzerClassName}) {
      $self->{fullTextAnalyzerClassName} = $vals->{fullTextAnalyzerClassName};
    }
    if (defined $vals->{columnFamilyDefinitions}) {
      $self->{columnFamilyDefinitions} = $vals->{columnFamilyDefinitions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AnalyzerDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{defaultDefinition} = new Blur::ColumnDefinition();
        $xfer += $self->{defaultDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{fullTextAnalyzerClassName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size18 = 0;
          $self->{columnFamilyDefinitions} = {};
          my $_ktype19 = 0;
          my $_vtype20 = 0;
          $xfer += $input->readMapBegin(\$_ktype19, \$_vtype20, \$_size18);
          for (my $_i22 = 0; $_i22 < $_size18; ++$_i22)
          {
            my $key23 = '';
            my $val24 = new Blur::ColumnFamilyDefinition();
            $xfer += $input->readString(\$key23);
            $val24 = new Blur::ColumnFamilyDefinition();
            $xfer += $val24->read($input);
            $self->{columnFamilyDefinitions}->{$key23} = $val24;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AnalyzerDefinition');
  if (defined $self->{defaultDefinition}) {
    $xfer += $output->writeFieldBegin('defaultDefinition', TType::STRUCT, 1);
    $xfer += $self->{defaultDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fullTextAnalyzerClassName}) {
    $xfer += $output->writeFieldBegin('fullTextAnalyzerClassName', TType::STRING, 2);
    $xfer += $output->writeString($self->{fullTextAnalyzerClassName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamilyDefinitions}) {
    $xfer += $output->writeFieldBegin('columnFamilyDefinitions', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{columnFamilyDefinitions}}));
      {
        while( my ($kiter25,$viter26) = each %{$self->{columnFamilyDefinitions}}) 
        {
          $xfer += $output->writeString($kiter25);
          $xfer += ${viter26}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Selector;
use base qw(Class::Accessor);
Blur::Selector->mk_accessors( qw( recordOnly locationId rowId recordId columnFamiliesToFetch columnsToFetch allowStaleData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordOnly} = undef;
  $self->{locationId} = undef;
  $self->{rowId} = undef;
  $self->{recordId} = undef;
  $self->{columnFamiliesToFetch} = undef;
  $self->{columnsToFetch} = undef;
  $self->{allowStaleData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordOnly}) {
      $self->{recordOnly} = $vals->{recordOnly};
    }
    if (defined $vals->{locationId}) {
      $self->{locationId} = $vals->{locationId};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
    if (defined $vals->{recordId}) {
      $self->{recordId} = $vals->{recordId};
    }
    if (defined $vals->{columnFamiliesToFetch}) {
      $self->{columnFamiliesToFetch} = $vals->{columnFamiliesToFetch};
    }
    if (defined $vals->{columnsToFetch}) {
      $self->{columnsToFetch} = $vals->{columnsToFetch};
    }
    if (defined $vals->{allowStaleData}) {
      $self->{allowStaleData} = $vals->{allowStaleData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Selector';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{recordOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size27 = 0;
          $self->{columnFamiliesToFetch} = {};
          my $_etype30 = 0;
          $xfer += $input->readSetBegin(\$_etype30, \$_size27);
          for (my $_i31 = 0; $_i31 < $_size27; ++$_i31)
          {
            my $elem32 = undef;
            $xfer += $input->readString(\$elem32);
            $self->{columnFamiliesToFetch}->{$elem32} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size33 = 0;
          $self->{columnsToFetch} = {};
          my $_ktype34 = 0;
          my $_vtype35 = 0;
          $xfer += $input->readMapBegin(\$_ktype34, \$_vtype35, \$_size33);
          for (my $_i37 = 0; $_i37 < $_size33; ++$_i37)
          {
            my $key38 = '';
            my $val39 = [];
            $xfer += $input->readString(\$key38);
            {
              my $_size40 = 0;
              $val39 = {};
              my $_etype43 = 0;
              $xfer += $input->readSetBegin(\$_etype43, \$_size40);
              for (my $_i44 = 0; $_i44 < $_size40; ++$_i44)
              {
                my $elem45 = undef;
                $xfer += $input->readString(\$elem45);
                $val39->{$elem45} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{columnsToFetch}->{$key38} = $val39;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{allowStaleData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Selector');
  if (defined $self->{recordOnly}) {
    $xfer += $output->writeFieldBegin('recordOnly', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{recordOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{locationId}) {
    $xfer += $output->writeFieldBegin('locationId', TType::STRING, 2);
    $xfer += $output->writeString($self->{locationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 3);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordId}) {
    $xfer += $output->writeFieldBegin('recordId', TType::STRING, 4);
    $xfer += $output->writeString($self->{recordId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamiliesToFetch}) {
    $xfer += $output->writeFieldBegin('columnFamiliesToFetch', TType::SET, 5);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{columnFamiliesToFetch}}));
      {
        foreach my $iter46 (@{$self->{columnFamiliesToFetch}})
        {
          $xfer += $output->writeString($iter46);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnsToFetch}) {
    $xfer += $output->writeFieldBegin('columnsToFetch', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::SET, scalar(keys %{$self->{columnsToFetch}}));
      {
        while( my ($kiter47,$viter48) = each %{$self->{columnsToFetch}}) 
        {
          $xfer += $output->writeString($kiter47);
          {
            $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter48}}));
            {
              foreach my $iter49 (@{${viter48}})
              {
                $xfer += $output->writeString($iter49);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{allowStaleData}) {
    $xfer += $output->writeFieldBegin('allowStaleData', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{allowStaleData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Facet;
use base qw(Class::Accessor);
Blur::Facet->mk_accessors( qw( queryStr minimumNumberOfBlurResults ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queryStr} = undef;
  $self->{minimumNumberOfBlurResults} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queryStr}) {
      $self->{queryStr} = $vals->{queryStr};
    }
    if (defined $vals->{minimumNumberOfBlurResults}) {
      $self->{minimumNumberOfBlurResults} = $vals->{minimumNumberOfBlurResults};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Facet';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{queryStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minimumNumberOfBlurResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Facet');
  if (defined $self->{queryStr}) {
    $xfer += $output->writeFieldBegin('queryStr', TType::STRING, 1);
    $xfer += $output->writeString($self->{queryStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{minimumNumberOfBlurResults}) {
    $xfer += $output->writeFieldBegin('minimumNumberOfBlurResults', TType::I64, 2);
    $xfer += $output->writeI64($self->{minimumNumberOfBlurResults});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Column;
use base qw(Class::Accessor);
Blur::Column->mk_accessors( qw( name value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Column';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Column');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Record;
use base qw(Class::Accessor);
Blur::Record->mk_accessors( qw( recordId family columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordId} = undef;
  $self->{family} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordId}) {
      $self->{recordId} = $vals->{recordId};
    }
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Record';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size50 = 0;
          $self->{columns} = [];
          my $_etype53 = 0;
          $xfer += $input->readListBegin(\$_etype53, \$_size50);
          for (my $_i54 = 0; $_i54 < $_size50; ++$_i54)
          {
            my $elem55 = undef;
            $elem55 = new Blur::Column();
            $xfer += $elem55->read($input);
            push(@{$self->{columns}},$elem55);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Record');
  if (defined $self->{recordId}) {
    $xfer += $output->writeFieldBegin('recordId', TType::STRING, 1);
    $xfer += $output->writeString($self->{recordId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 2);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter56 (@{$self->{columns}}) 
        {
          $xfer += ${iter56}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Row;
use base qw(Class::Accessor);
Blur::Row->mk_accessors( qw( id records ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{records} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{records}) {
      $self->{records} = $vals->{records};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Row';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size57 = 0;
          $self->{records} = [];
          my $_etype60 = 0;
          $xfer += $input->readListBegin(\$_etype60, \$_size57);
          for (my $_i61 = 0; $_i61 < $_size57; ++$_i61)
          {
            my $elem62 = undef;
            $elem62 = new Blur::Record();
            $xfer += $elem62->read($input);
            push(@{$self->{records}},$elem62);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Row');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
    $xfer += $output->writeString($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{records}) {
    $xfer += $output->writeFieldBegin('records', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{records}}));
      {
        foreach my $iter63 (@{$self->{records}}) 
        {
          $xfer += ${iter63}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchRowResult;
use base qw(Class::Accessor);
Blur::FetchRowResult->mk_accessors( qw( row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchRowResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{row} = new Blur::Row();
        $xfer += $self->{row}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchRowResult');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRUCT, 1);
    $xfer += $self->{row}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchRecordResult;
use base qw(Class::Accessor);
Blur::FetchRecordResult->mk_accessors( qw( rowid record ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{rowid} = undef;
  $self->{record} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{rowid}) {
      $self->{rowid} = $vals->{rowid};
    }
    if (defined $vals->{record}) {
      $self->{record} = $vals->{record};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchRecordResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{record} = new Blur::Record();
        $xfer += $self->{record}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchRecordResult');
  if (defined $self->{rowid}) {
    $xfer += $output->writeFieldBegin('rowid', TType::STRING, 1);
    $xfer += $output->writeString($self->{rowid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{record}) {
    $xfer += $output->writeFieldBegin('record', TType::STRUCT, 2);
    $xfer += $self->{record}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchResult;
use base qw(Class::Accessor);
Blur::FetchResult->mk_accessors( qw( exists deleted table rowResult recordResult ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{exists} = undef;
  $self->{deleted} = undef;
  $self->{table} = undef;
  $self->{rowResult} = undef;
  $self->{recordResult} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{exists}) {
      $self->{exists} = $vals->{exists};
    }
    if (defined $vals->{deleted}) {
      $self->{deleted} = $vals->{deleted};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{rowResult}) {
      $self->{rowResult} = $vals->{rowResult};
    }
    if (defined $vals->{recordResult}) {
      $self->{recordResult} = $vals->{recordResult};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleted});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{rowResult} = new Blur::FetchRowResult();
        $xfer += $self->{rowResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{recordResult} = new Blur::FetchRecordResult();
        $xfer += $self->{recordResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchResult');
  if (defined $self->{exists}) {
    $xfer += $output->writeFieldBegin('exists', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{exists});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleted}) {
    $xfer += $output->writeFieldBegin('deleted', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleted});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 3);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowResult}) {
    $xfer += $output->writeFieldBegin('rowResult', TType::STRUCT, 4);
    $xfer += $self->{rowResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordResult}) {
    $xfer += $output->writeFieldBegin('recordResult', TType::STRUCT, 5);
    $xfer += $self->{recordResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::SimpleQuery;
use base qw(Class::Accessor);
Blur::SimpleQuery->mk_accessors( qw( queryStr superQueryOn type postSuperFilter preSuperFilter ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queryStr} = undef;
  $self->{superQueryOn} = 1;
  $self->{type} = 0;
  $self->{postSuperFilter} = undef;
  $self->{preSuperFilter} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queryStr}) {
      $self->{queryStr} = $vals->{queryStr};
    }
    if (defined $vals->{superQueryOn}) {
      $self->{superQueryOn} = $vals->{superQueryOn};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{postSuperFilter}) {
      $self->{postSuperFilter} = $vals->{postSuperFilter};
    }
    if (defined $vals->{preSuperFilter}) {
      $self->{preSuperFilter} = $vals->{preSuperFilter};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SimpleQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{queryStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{superQueryOn});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{postSuperFilter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{preSuperFilter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SimpleQuery');
  if (defined $self->{queryStr}) {
    $xfer += $output->writeFieldBegin('queryStr', TType::STRING, 1);
    $xfer += $output->writeString($self->{queryStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{superQueryOn}) {
    $xfer += $output->writeFieldBegin('superQueryOn', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{superQueryOn});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 3);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{postSuperFilter}) {
    $xfer += $output->writeFieldBegin('postSuperFilter', TType::STRING, 4);
    $xfer += $output->writeString($self->{postSuperFilter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{preSuperFilter}) {
    $xfer += $output->writeFieldBegin('preSuperFilter', TType::STRING, 5);
    $xfer += $output->writeString($self->{preSuperFilter});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ExpertQuery;
use base qw(Class::Accessor);
Blur::ExpertQuery->mk_accessors( qw( query filter sort ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{filter} = undef;
  $self->{sort} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
    if (defined $vals->{sort}) {
      $self->{sort} = $vals->{sort};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ExpertQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{filter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{sort});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ExpertQuery');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRING, 2);
    $xfer += $output->writeString($self->{filter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sort}) {
    $xfer += $output->writeFieldBegin('sort', TType::STRING, 3);
    $xfer += $output->writeString($self->{sort});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurQuery;
use base qw(Class::Accessor);
Blur::BlurQuery->mk_accessors( qw( simpleQuery expertQuery start fetch minimumNumberOfResults maxQueryTime uuid userId resolveIds facets selector startTime cacheOnly allowStaleData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{simpleQuery} = undef;
  $self->{expertQuery} = undef;
  $self->{start} = 0;
  $self->{fetch} = 10;
  $self->{minimumNumberOfResults} = 9223372036854775807;
  $self->{maxQueryTime} = 9223372036854775807;
  $self->{uuid} = undef;
  $self->{userId} = undef;
  $self->{resolveIds} = undef;
  $self->{facets} = undef;
  $self->{selector} = undef;
  $self->{startTime} = undef;
  $self->{cacheOnly} = 0;
  $self->{allowStaleData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{simpleQuery}) {
      $self->{simpleQuery} = $vals->{simpleQuery};
    }
    if (defined $vals->{expertQuery}) {
      $self->{expertQuery} = $vals->{expertQuery};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{fetch}) {
      $self->{fetch} = $vals->{fetch};
    }
    if (defined $vals->{minimumNumberOfResults}) {
      $self->{minimumNumberOfResults} = $vals->{minimumNumberOfResults};
    }
    if (defined $vals->{maxQueryTime}) {
      $self->{maxQueryTime} = $vals->{maxQueryTime};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
    if (defined $vals->{userId}) {
      $self->{userId} = $vals->{userId};
    }
    if (defined $vals->{resolveIds}) {
      $self->{resolveIds} = $vals->{resolveIds};
    }
    if (defined $vals->{facets}) {
      $self->{facets} = $vals->{facets};
    }
    if (defined $vals->{selector}) {
      $self->{selector} = $vals->{selector};
    }
    if (defined $vals->{startTime}) {
      $self->{startTime} = $vals->{startTime};
    }
    if (defined $vals->{cacheOnly}) {
      $self->{cacheOnly} = $vals->{cacheOnly};
    }
    if (defined $vals->{allowStaleData}) {
      $self->{allowStaleData} = $vals->{allowStaleData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{simpleQuery} = new Blur::SimpleQuery();
        $xfer += $self->{simpleQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{expertQuery} = new Blur::ExpertQuery();
        $xfer += $self->{expertQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{fetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minimumNumberOfResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{maxQueryTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{userId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{resolveIds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size64 = 0;
          $self->{facets} = [];
          my $_etype67 = 0;
          $xfer += $input->readListBegin(\$_etype67, \$_size64);
          for (my $_i68 = 0; $_i68 < $_size64; ++$_i68)
          {
            my $elem69 = undef;
            $elem69 = new Blur::Facet();
            $xfer += $elem69->read($input);
            push(@{$self->{facets}},$elem69);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{selector} = new Blur::Selector();
        $xfer += $self->{selector}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{startTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{cacheOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{allowStaleData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurQuery');
  if (defined $self->{simpleQuery}) {
    $xfer += $output->writeFieldBegin('simpleQuery', TType::STRUCT, 1);
    $xfer += $self->{simpleQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expertQuery}) {
    $xfer += $output->writeFieldBegin('expertQuery', TType::STRUCT, 2);
    $xfer += $self->{expertQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::I64, 3);
    $xfer += $output->writeI64($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetch}) {
    $xfer += $output->writeFieldBegin('fetch', TType::I32, 4);
    $xfer += $output->writeI32($self->{fetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{minimumNumberOfResults}) {
    $xfer += $output->writeFieldBegin('minimumNumberOfResults', TType::I64, 5);
    $xfer += $output->writeI64($self->{minimumNumberOfResults});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxQueryTime}) {
    $xfer += $output->writeFieldBegin('maxQueryTime', TType::I64, 6);
    $xfer += $output->writeI64($self->{maxQueryTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 7);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userId}) {
    $xfer += $output->writeFieldBegin('userId', TType::STRING, 8);
    $xfer += $output->writeString($self->{userId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{resolveIds}) {
    $xfer += $output->writeFieldBegin('resolveIds', TType::BOOL, 9);
    $xfer += $output->writeBool($self->{resolveIds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{facets}) {
    $xfer += $output->writeFieldBegin('facets', TType::LIST, 10);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{facets}}));
      {
        foreach my $iter70 (@{$self->{facets}}) 
        {
          $xfer += ${iter70}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selector}) {
    $xfer += $output->writeFieldBegin('selector', TType::STRUCT, 11);
    $xfer += $self->{selector}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startTime}) {
    $xfer += $output->writeFieldBegin('startTime', TType::I64, 12);
    $xfer += $output->writeI64($self->{startTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cacheOnly}) {
    $xfer += $output->writeFieldBegin('cacheOnly', TType::BOOL, 13);
    $xfer += $output->writeBool($self->{cacheOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{allowStaleData}) {
    $xfer += $output->writeFieldBegin('allowStaleData', TType::BOOL, 14);
    $xfer += $output->writeBool($self->{allowStaleData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurResult;
use base qw(Class::Accessor);
Blur::BlurResult->mk_accessors( qw( locationId score fetchResult ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{locationId} = undef;
  $self->{score} = undef;
  $self->{fetchResult} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{locationId}) {
      $self->{locationId} = $vals->{locationId};
    }
    if (defined $vals->{score}) {
      $self->{score} = $vals->{score};
    }
    if (defined $vals->{fetchResult}) {
      $self->{fetchResult} = $vals->{fetchResult};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{score});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{fetchResult} = new Blur::FetchResult();
        $xfer += $self->{fetchResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurResult');
  if (defined $self->{locationId}) {
    $xfer += $output->writeFieldBegin('locationId', TType::STRING, 1);
    $xfer += $output->writeString($self->{locationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{score}) {
    $xfer += $output->writeFieldBegin('score', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{score});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetchResult}) {
    $xfer += $output->writeFieldBegin('fetchResult', TType::STRUCT, 3);
    $xfer += $self->{fetchResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurResults;
use base qw(Class::Accessor);
Blur::BlurResults->mk_accessors( qw( totalResults shardInfo results exceptions query realTime cpuTime facetCounts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{totalResults} = 0;
  $self->{shardInfo} = undef;
  $self->{results} = undef;
  $self->{exceptions} = undef;
  $self->{query} = undef;
  $self->{realTime} = undef;
  $self->{cpuTime} = undef;
  $self->{facetCounts} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{totalResults}) {
      $self->{totalResults} = $vals->{totalResults};
    }
    if (defined $vals->{shardInfo}) {
      $self->{shardInfo} = $vals->{shardInfo};
    }
    if (defined $vals->{results}) {
      $self->{results} = $vals->{results};
    }
    if (defined $vals->{exceptions}) {
      $self->{exceptions} = $vals->{exceptions};
    }
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{realTime}) {
      $self->{realTime} = $vals->{realTime};
    }
    if (defined $vals->{cpuTime}) {
      $self->{cpuTime} = $vals->{cpuTime};
    }
    if (defined $vals->{facetCounts}) {
      $self->{facetCounts} = $vals->{facetCounts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurResults';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{totalResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size71 = 0;
          $self->{shardInfo} = {};
          my $_ktype72 = 0;
          my $_vtype73 = 0;
          $xfer += $input->readMapBegin(\$_ktype72, \$_vtype73, \$_size71);
          for (my $_i75 = 0; $_i75 < $_size71; ++$_i75)
          {
            my $key76 = '';
            my $val77 = 0;
            $xfer += $input->readString(\$key76);
            $xfer += $input->readI64(\$val77);
            $self->{shardInfo}->{$key76} = $val77;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size78 = 0;
          $self->{results} = [];
          my $_etype81 = 0;
          $xfer += $input->readListBegin(\$_etype81, \$_size78);
          for (my $_i82 = 0; $_i82 < $_size78; ++$_i82)
          {
            my $elem83 = undef;
            $elem83 = new Blur::BlurResult();
            $xfer += $elem83->read($input);
            push(@{$self->{results}},$elem83);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size84 = 0;
          $self->{exceptions} = [];
          my $_etype87 = 0;
          $xfer += $input->readListBegin(\$_etype87, \$_size84);
          for (my $_i88 = 0; $_i88 < $_size84; ++$_i88)
          {
            my $elem89 = undef;
            $elem89 = new Blur::BlurException();
            $xfer += $elem89->read($input);
            push(@{$self->{exceptions}},$elem89);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::BlurQuery();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{realTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{cpuTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size90 = 0;
          $self->{facetCounts} = [];
          my $_etype93 = 0;
          $xfer += $input->readListBegin(\$_etype93, \$_size90);
          for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
          {
            my $elem95 = undef;
            $xfer += $input->readI64(\$elem95);
            push(@{$self->{facetCounts}},$elem95);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurResults');
  if (defined $self->{totalResults}) {
    $xfer += $output->writeFieldBegin('totalResults', TType::I64, 1);
    $xfer += $output->writeI64($self->{totalResults});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shardInfo}) {
    $xfer += $output->writeFieldBegin('shardInfo', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I64, scalar(keys %{$self->{shardInfo}}));
      {
        while( my ($kiter96,$viter97) = each %{$self->{shardInfo}}) 
        {
          $xfer += $output->writeString($kiter96);
          $xfer += $output->writeI64($viter97);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{results}) {
    $xfer += $output->writeFieldBegin('results', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{results}}));
      {
        foreach my $iter98 (@{$self->{results}}) 
        {
          $xfer += ${iter98}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{exceptions}) {
    $xfer += $output->writeFieldBegin('exceptions', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{exceptions}}));
      {
        foreach my $iter99 (@{$self->{exceptions}}) 
        {
          $xfer += ${iter99}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 5);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{realTime}) {
    $xfer += $output->writeFieldBegin('realTime', TType::I64, 6);
    $xfer += $output->writeI64($self->{realTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cpuTime}) {
    $xfer += $output->writeFieldBegin('cpuTime', TType::I64, 7);
    $xfer += $output->writeI64($self->{cpuTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{facetCounts}) {
    $xfer += $output->writeFieldBegin('facetCounts', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::I64, scalar(@{$self->{facetCounts}}));
      {
        foreach my $iter100 (@{$self->{facetCounts}}) 
        {
          $xfer += $output->writeI64($iter100);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TableDescriptor;
use base qw(Class::Accessor);
Blur::TableDescriptor->mk_accessors( qw( isEnabled analyzerDefinition shardCount tableUri compressionClass compressionBlockSize cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{isEnabled} = 1;
  $self->{analyzerDefinition} = undef;
  $self->{shardCount} = 1;
  $self->{tableUri} = undef;
  $self->{compressionClass} = "org.apache.hadoop.io.compress.DefaultCodec";
  $self->{compressionBlockSize} = 32768;
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{isEnabled}) {
      $self->{isEnabled} = $vals->{isEnabled};
    }
    if (defined $vals->{analyzerDefinition}) {
      $self->{analyzerDefinition} = $vals->{analyzerDefinition};
    }
    if (defined $vals->{shardCount}) {
      $self->{shardCount} = $vals->{shardCount};
    }
    if (defined $vals->{tableUri}) {
      $self->{tableUri} = $vals->{tableUri};
    }
    if (defined $vals->{compressionClass}) {
      $self->{compressionClass} = $vals->{compressionClass};
    }
    if (defined $vals->{compressionBlockSize}) {
      $self->{compressionBlockSize} = $vals->{compressionBlockSize};
    }
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableDescriptor';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{isEnabled});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{analyzerDefinition} = new Blur::AnalyzerDefinition();
        $xfer += $self->{analyzerDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{shardCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableUri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{compressionClass});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{compressionBlockSize});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableDescriptor');
  if (defined $self->{isEnabled}) {
    $xfer += $output->writeFieldBegin('isEnabled', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{isEnabled});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{analyzerDefinition}) {
    $xfer += $output->writeFieldBegin('analyzerDefinition', TType::STRUCT, 2);
    $xfer += $self->{analyzerDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shardCount}) {
    $xfer += $output->writeFieldBegin('shardCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{shardCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableUri}) {
    $xfer += $output->writeFieldBegin('tableUri', TType::STRING, 4);
    $xfer += $output->writeString($self->{tableUri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compressionClass}) {
    $xfer += $output->writeFieldBegin('compressionClass', TType::STRING, 5);
    $xfer += $output->writeString($self->{compressionClass});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compressionBlockSize}) {
    $xfer += $output->writeFieldBegin('compressionBlockSize', TType::I32, 6);
    $xfer += $output->writeI32($self->{compressionBlockSize});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 7);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::CpuTime;
use base qw(Class::Accessor);
Blur::CpuTime->mk_accessors( qw( cpuTime realTime ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cpuTime} = undef;
  $self->{realTime} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cpuTime}) {
      $self->{cpuTime} = $vals->{cpuTime};
    }
    if (defined $vals->{realTime}) {
      $self->{realTime} = $vals->{realTime};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CpuTime';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{cpuTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{realTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CpuTime');
  if (defined $self->{cpuTime}) {
    $xfer += $output->writeFieldBegin('cpuTime', TType::I64, 1);
    $xfer += $output->writeI64($self->{cpuTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{realTime}) {
    $xfer += $output->writeFieldBegin('realTime', TType::I64, 2);
    $xfer += $output->writeI64($self->{realTime});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurQueryStatus;
use base qw(Class::Accessor);
Blur::BlurQueryStatus->mk_accessors( qw( query cpuTimes completeShards totalShards state uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{cpuTimes} = undef;
  $self->{completeShards} = undef;
  $self->{totalShards} = undef;
  $self->{state} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{cpuTimes}) {
      $self->{cpuTimes} = $vals->{cpuTimes};
    }
    if (defined $vals->{completeShards}) {
      $self->{completeShards} = $vals->{completeShards};
    }
    if (defined $vals->{totalShards}) {
      $self->{totalShards} = $vals->{totalShards};
    }
    if (defined $vals->{state}) {
      $self->{state} = $vals->{state};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurQueryStatus';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::BlurQuery();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size101 = 0;
          $self->{cpuTimes} = {};
          my $_ktype102 = 0;
          my $_vtype103 = 0;
          $xfer += $input->readMapBegin(\$_ktype102, \$_vtype103, \$_size101);
          for (my $_i105 = 0; $_i105 < $_size101; ++$_i105)
          {
            my $key106 = '';
            my $val107 = new Blur::CpuTime();
            $xfer += $input->readString(\$key106);
            $val107 = new Blur::CpuTime();
            $xfer += $val107->read($input);
            $self->{cpuTimes}->{$key106} = $val107;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{completeShards});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{totalShards});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{state});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurQueryStatus');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 1);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cpuTimes}) {
    $xfer += $output->writeFieldBegin('cpuTimes', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{cpuTimes}}));
      {
        while( my ($kiter108,$viter109) = each %{$self->{cpuTimes}}) 
        {
          $xfer += $output->writeString($kiter108);
          $xfer += ${viter109}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{completeShards}) {
    $xfer += $output->writeFieldBegin('completeShards', TType::I32, 3);
    $xfer += $output->writeI32($self->{completeShards});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{totalShards}) {
    $xfer += $output->writeFieldBegin('totalShards', TType::I32, 4);
    $xfer += $output->writeI32($self->{totalShards});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{state}) {
    $xfer += $output->writeFieldBegin('state', TType::I32, 5);
    $xfer += $output->writeI32($self->{state});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 6);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Schema;
use base qw(Class::Accessor);
Blur::Schema->mk_accessors( qw( table columnFamilies ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamilies} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamilies}) {
      $self->{columnFamilies} = $vals->{columnFamilies};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Schema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size110 = 0;
          $self->{columnFamilies} = {};
          my $_ktype111 = 0;
          my $_vtype112 = 0;
          $xfer += $input->readMapBegin(\$_ktype111, \$_vtype112, \$_size110);
          for (my $_i114 = 0; $_i114 < $_size110; ++$_i114)
          {
            my $key115 = '';
            my $val116 = [];
            $xfer += $input->readString(\$key115);
            {
              my $_size117 = 0;
              $val116 = {};
              my $_etype120 = 0;
              $xfer += $input->readSetBegin(\$_etype120, \$_size117);
              for (my $_i121 = 0; $_i121 < $_size117; ++$_i121)
              {
                my $elem122 = undef;
                $xfer += $input->readString(\$elem122);
                $val116->{$elem122} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{columnFamilies}->{$key115} = $val116;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Schema');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamilies}) {
    $xfer += $output->writeFieldBegin('columnFamilies', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::SET, scalar(keys %{$self->{columnFamilies}}));
      {
        while( my ($kiter123,$viter124) = each %{$self->{columnFamilies}}) 
        {
          $xfer += $output->writeString($kiter123);
          {
            $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter124}}));
            {
              foreach my $iter125 (@{${viter124}})
              {
                $xfer += $output->writeString($iter125);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::RecordMutation;
use base qw(Class::Accessor);
Blur::RecordMutation->mk_accessors( qw( recordMutationType record ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordMutationType} = undef;
  $self->{record} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordMutationType}) {
      $self->{recordMutationType} = $vals->{recordMutationType};
    }
    if (defined $vals->{record}) {
      $self->{record} = $vals->{record};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecordMutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{recordMutationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{record} = new Blur::Record();
        $xfer += $self->{record}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecordMutation');
  if (defined $self->{recordMutationType}) {
    $xfer += $output->writeFieldBegin('recordMutationType', TType::I32, 1);
    $xfer += $output->writeI32($self->{recordMutationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{record}) {
    $xfer += $output->writeFieldBegin('record', TType::STRUCT, 2);
    $xfer += $self->{record}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::RowMutation;
use base qw(Class::Accessor);
Blur::RowMutation->mk_accessors( qw( table rowId wal rowMutationType recordMutations ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{rowId} = undef;
  $self->{wal} = 1;
  $self->{rowMutationType} = undef;
  $self->{recordMutations} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
    if (defined $vals->{wal}) {
      $self->{wal} = $vals->{wal};
    }
    if (defined $vals->{rowMutationType}) {
      $self->{rowMutationType} = $vals->{rowMutationType};
    }
    if (defined $vals->{recordMutations}) {
      $self->{recordMutations} = $vals->{recordMutations};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RowMutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{wal});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{rowMutationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size126 = 0;
          $self->{recordMutations} = [];
          my $_etype129 = 0;
          $xfer += $input->readListBegin(\$_etype129, \$_size126);
          for (my $_i130 = 0; $_i130 < $_size126; ++$_i130)
          {
            my $elem131 = undef;
            $elem131 = new Blur::RecordMutation();
            $xfer += $elem131->read($input);
            push(@{$self->{recordMutations}},$elem131);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RowMutation');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 2);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{wal}) {
    $xfer += $output->writeFieldBegin('wal', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{wal});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowMutationType}) {
    $xfer += $output->writeFieldBegin('rowMutationType', TType::I32, 4);
    $xfer += $output->writeI32($self->{rowMutationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordMutations}) {
    $xfer += $output->writeFieldBegin('recordMutations', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{recordMutations}}));
      {
        foreach my $iter132 (@{$self->{recordMutations}}) 
        {
          $xfer += ${iter132}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TableStats;
use base qw(Class::Accessor);
Blur::TableStats->mk_accessors( qw( tableName bytes recordCount rowCount queries ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{bytes} = undef;
  $self->{recordCount} = undef;
  $self->{rowCount} = undef;
  $self->{queries} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{bytes}) {
      $self->{bytes} = $vals->{bytes};
    }
    if (defined $vals->{recordCount}) {
      $self->{recordCount} = $vals->{recordCount};
    }
    if (defined $vals->{rowCount}) {
      $self->{rowCount} = $vals->{rowCount};
    }
    if (defined $vals->{queries}) {
      $self->{queries} = $vals->{queries};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableStats';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{bytes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{recordCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{rowCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{queries});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableStats');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bytes}) {
    $xfer += $output->writeFieldBegin('bytes', TType::I64, 2);
    $xfer += $output->writeI64($self->{bytes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordCount}) {
    $xfer += $output->writeFieldBegin('recordCount', TType::I64, 3);
    $xfer += $output->writeI64($self->{recordCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowCount}) {
    $xfer += $output->writeFieldBegin('rowCount', TType::I64, 4);
    $xfer += $output->writeI64($self->{rowCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{queries}) {
    $xfer += $output->writeFieldBegin('queries', TType::I64, 5);
    $xfer += $output->writeI64($self->{queries});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
